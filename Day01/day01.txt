网络编程

网络功能 : 数据的传输

1.ISO(国际标准化组织)

 OSI七层模型 --------- > 网络通信工作流程标准化

    应用层:     提供用户服务,具体功能由特定的程序而定
    表示层:     数据的压缩优化,加密
    会话层:     建立应用级的连接,选择适当的传输服务
    传输层:     提供不同的传输服务,流量控制
    网络层:     路由选择,网络互连
    链路层:     进行数据转换,具体消息的发送,链路连接
    物理层:     提供了数据传输的硬件,网卡 ,接口设定,网卡路由交换机等

    OSI七层模型优点:
        1.建立了统一的工作流程
        2.分步清晰,每一步各司其职
        3.降低了通信模块的耦合度

    cookie
        高内聚:模块功能尽可能单一,不要掺杂
        低耦合:模块之间尽可能减少关联和影响

2.四层模型(TCP/IP模型)
    应用层: 应用层,表示层,会话层
    传输层
    网络层
    物理链路层
    *将应用层,表示层,会话层功能统一由应用层完成,便于应用的开发


3.五层模型
    应用层
    传输层
    网络层
    链路层
    物理层

4.数据的传输流程
    1.发送端由应用层到物理层逐层添加首部信息,最终在物理层发送信息包
    2.发送的信息中间经过多个节点传送(路由基站交换机等)最终到达目标主机
    3.目标主机逐层解析信息包,最终由应用层呈现数据信息

5.网络协议
    1.网络通信中双方都遵循的规定.包括建立什么样的数据结构,消息结构等

6.网络编程概念
    网络主机:
        在网络中标识一台计算机    host    
        本地使用:(只有自己访问)
            'localhost'
            '127.0.0.1'
        网络使用:(别人也可以访问)
            '0.0.0.0'
            ip地址
    
        ifconfig: 查看本机的IP信息

    获取计算机名
    In [9]: socket.gethostname()
    Out[9]: 'tedu'

    获取计算机的网络地址
    In [8]: socket.gethostbyname('localhost')
    Out[8]: '127.0.0.1'

    IP地址
        在网络上确定一台主机的网络路由位置

        IPv4:
            点分十进制      192.168.1.2      0--255    32位   C类地址
        IPv6:
            点十六进制      00:0c:29:56:02:14   128位

        ping ip :
            连接测试命令

    特殊IP
        127.0.0.1       本机测试IP
        0.0.0.0         使用本机能够使用的网卡地址
        192.168.56.0    表达一个网段
        192.168.56.1    通常标识网关地址(路由地址)
        192.168.56.255  广播地址

    域名
        网络服务器的地址的别名
        1.方便记忆
        2.表达一定的含义

    端口号: Port
        端口是网络地址的一部分,用于区分网络主机上不同的网络应用程序
    
        *在一个系统中应用监听的端口号不能重复

        取值范围: 1-65535
            1-255       一些众所周知的公共程序端口
            256-1023    系统应用端口
            1024-65535  自用端口
        
        获取一个应用的端口
            In [3]: socket.getservbyname('mysql')
            Out[3]: 3306

    传输层服务:

        面向连接的传输服务(基于TCP的数据传输)
            传输特征:
                提供可靠地数据,可靠性指数据传输过程中无丢失,无失序,无差错,无重复
            实现手段:
                在通信前需要建立数据连接,通信结束要正常断开连接 
            连接(三次握手)
                1.client--->server  发送连接标志变量表示请求连接
                2.server--->client  服务器收到请求后,回复变量标志确定可连接
                3.client--->server  客户端收到回复,发送最终连接标志建立连接
            断开连接(四次挥手)
                1.主动方发送标志表示请求断开连接
                2.被动方收到请求后,立即回复信息表示已经接受请求
                3.被动方消息处理完毕,再次发送标志表示已经准备可以断开
                4.主动方收到被动方标志,发送最终断开标识,连接断开
            适用情况:
                对数据准确性有明确要求,传输数据文件较大,需要确保可靠性传输的情况.
                比如:
                    网页获取,文件下载,邮件收发等
            
            
        面向无连接的传输服务(基于UDP的数据传输)
            传输特征:
                不保证传输的可靠性,传输过程中没有连接和断开的过程,数据自由收发
            适用情况:
                网络较差,对传输可靠性要求不高.如果使用TCP效率较低
            比如:
                网络视频,群聊,广播

要求:
    1.osi七层模式介绍以下,tcp/ip模式是什么
    2.TCP服务和UDP有什么异同
    3.三次握手和四次挥手是什么,过程是怎样的


7.网络层编程
    socket模块
        套接字: 实现网络编程,进行数据传输的一种技术手段

        使用socket模块提供接口函数进行组合搭配,完成网络套接字编程

        套接字分类:
            流式套接字(SOCK_STREAM) : TCP传输
            数据报套接字(SOCK_DGRAM) : UDP传输

            面向连接--TCP协议--可靠的--流式套接字
            面向无连接--UDP协议--不可靠--数据报套接字

    TCP套接字编程:

        服务端流程:
            socket()--->bind()--->listen()--->accept()--->recv()/send()--->close()

            1.创建套接字

                sockfd = socket.socket(socket_family = AD_INET,
                                        socket_type = SOCK_STREAM,
                                        proto = 0)

                    功能:    
                        创建套接字
                    参数:    
                            socket_family      地址族类型         AF_INET--->IPv4
                            socket_type         套接字类型        SOCK_STREAM--->流式套接字
                                                                SOCK_DGRAM--->数据报套接字
                            proto               通常为0
                    返回值:   
                        返回套接字对象 

            2.绑定地址

                sockfd.bind(addr)

                    功能:
                        绑定本机的网络地址
                    参数:
                        元祖(ip,port) ('192.168,56,140',8888)

            3.设置监听

                sockfd.listen(n)
                
                    功能:
                        将套接字设置为监听套接字并且创建监听队列
                    参数:
                        n   设置监听队列的大小

            4.等待处理客户端连接请求

                connfd, addr = sockfd.accept()

                    功能:
                        阻塞等待处理客户端请求

                    返回值:
                        connfd--->连接客户端的连接套接字
                        addr--->连接客户端的地址

                    *阻塞函数:
                        程序运行过程中遇到阻塞函数则暂停执行,直到达成某种条件后再继续执行

            5.收发消息

                data = connfd.recv(buffersize)

                    功能: 
                        接收消息
                    参数: 
                        每次最多接收多少字节消息
                    返回值: 
                        接收到的网络消息

                n = sockfd.send(data)

                    功能: 
                        发送消息
                    参数:
                        要发送的内容    bytes格式
                    返回值:
                        发送了多少个字节

            6.关闭套接字

                sockfd.close()

                    功能:
                        关闭套接字


        客户端流程: 

            socket()--->connect()--->send()/recv()--->close()

            1.创建套接字

                *只有相同类型套接字才能进行连接传输

            2.请求连接

                sockfd.connect(server_addr)

                功能:
                    连接服务端
                参数:
                    服务器地址,元祖

            3.收发消息

                *先发后收,防止两端都阻塞,收发函数使用要配合

            4.关闭套接字

作业:
    1.要求3个问题,总结口述
    2.将tcp两个程序改成可以循环发送接受信息
            








